import {} from "Monad"
import {} from "Alternative"
import { apL } from "Applicative"
import { Either, Right, Left } from "Either"
import { Just, Nothing } from "Maybe"
import { firstChar, drop, isEmpty, isDigit, isLetter } from "String"
import { includes, reduce } from "List"
import { always, complement, equals, ifElse, notEquals } from "Function"
import {} from "Number"

import IO from "IO"

export type Location = Loc Number Number Number

incLoc :: String -> Location -> Location
incLoc = (c) => where is Loc abs line col: c == "\n"
  ? Loc(abs + 1, line + 1, 0)
  : Loc(abs + 1, line, col + 1)

export type Parser a = Parser (String -> Location -> <List <a, String>, Location>)

type Error = Error Location

parse :: Parser a -> String -> Location -> <List <a, String>, Location>
parse = (parser, input, loc) => {
  parseFn = where(parser)
    is Parser fn: fn
  return parseFn(input, loc)
}

runParser :: Parser a -> String -> Either Error a
export runParser = (m, s) => where(parse(m, s, Loc(0, 0, 0)))
  is <[<res, "">], _>: Right(res)
  is <[<_, rest>], l>: Left(Error(l))
  is <_, l>          : Left(Error(l))

instance Functor Parser {
  map = (f, m) => Parser((s, l) => where(parse(m, s, l))
    is <[<a, b>], loc>: <[<f(a), b>], loc>
    is <[], loc>      : <[], loc>
  )
}

instance Applicative Parser {
  pure = (a) => Parser((s, l) => <[<a, s>], l>)

  ap = (parserA, parserB) => Parser((s, l) =>
    where(parse(parserA, s, l)) {
      is <[], l1>       : <[], l1>
      is <[<f, s1>], l1>: where(parse(parserB, s1, l1)) {
        is <[<a, s2>], l2>: <[<f(a), s2>], l2>
        is <[], l2>       : <[], l2>
      }
    }
  )
}

instance Monad Parser {
  of = pure

  chain = (f, m) => Parser((s, l) =>
    where(parse(m, s, l))
      is <[], ll>       : <[], ll>
      is <[<a, s1>], l1>: parse(f(a), s1, l1)
  )
}

instance Alternative Parser {
  empty = Parser((_, l) => <[], l>)

  alt = (ma, mb) => Parser((s, l) =>
    where(parse(ma, s, l))
      is <[], _> : parse(mb, s, l)
      is res     : res
  )
}

anyChar :: Parser String
export anyChar = Parser((s, l) => pipe(
  firstChar,
  where
    is Just c : <[<c, drop(1, s)>], incLoc(c, l)>
    is Nothing: <[], l>
)(s))

location :: Parser Location
export location = Parser((s, l) => <[<l, s>], l>)

oneOf :: List String -> Parser String
export oneOf = (cs) => satisfy(includes($, cs))

notOneOf :: List String -> Parser String
export notOneOf = (cs) => satisfy(complement(includes($, cs)))

choice :: List (Parser a) -> Parser a
export choice = (ps) => reduce(alt, empty, ps)

many :: Parser a -> Parser (List a)
export many = (p) => alt(some(p), pure([]))

some :: Parser a -> Parser (List a)
export some = (p) => chain(
  (first) => map(
    (rest) => mappend([first], rest),
    many(p)
  ),
  p
)

manyTill :: Parser a -> Parser b -> Parser (List a)
export manyTill = (p, end) => pipe(
  map(always(Just(()))),
  alt($, pure(Nothing)),
  chain(where
    is Just _ : pure([])
    is Nothing: chain((x) => map((y) => mappend([x], y), manyTill(p, end)), p)
  )
)(end)

someTill :: Parser a -> Parser b -> Parser (List a)
export someTill = (p, end) => chain(
  (first) => map(
    (rest) => mappend([first], rest),
    manyTill(p, end)
  ),
  p
)

lookAhead :: Parser a -> Parser a
export lookAhead = (p) => Parser((s, l) => where(parse(p, s, l))
  is <[<a, _>], _>: <[<a, s>], l>
  is _            : <[], l>
)

takeWhile :: (String -> Boolean) -> Parser String
export takeWhile = (pred) => {
  parser = Parser((s, l) => where(parse(anyChar, s, l))
    is <[], _>          : <[<"", s>], l>
    is <[<"", _>], _>   : <[<"", s>], l>
    is <[<c, rest>], ll>: pred(c) ? <[<c, rest>], ll> : <[<"", s>], l>
  )

  return chain(
    ifElse(
      isEmpty,
      pure,
      (x) => map((next) => x ++ next, takeWhile(pred))
    ),
    parser
  )
}

satisfy :: (String -> Boolean) -> Parser String
export satisfy = (pred) => chain(
  ifElse(pred, of, always(empty)),
  anyChar
)

char :: String -> Parser String
export char = pipe(equals, satisfy)

notChar :: String -> Parser String
export notChar = pipe(notEquals, satisfy)

eof :: Parser ()
export eof = Parser((s, l) => where(parse(anyChar, s, l))
  is <[], _>: <[<(), "">], l>
  is _ : <[], l>
)

string :: String -> Parser String
export string = (s) => where(firstChar(s))
  is Just c :
    pipe(
      map((a, b) => a ++ b),
      ap($, string(drop(1, s)))
    )(char(c))
  is Nothing: pure("")

spaces :: Parser String
export spaces = pipe(
  oneOf,
  some,
  map(reduce(mappend, ""))
)([" ", "\n", "\r", "\t"])

token :: Parser a -> Parser a
export token = apL($, spaces)

symbol :: String -> Parser String
export symbol = pipe(string, token)

digit :: Parser String
export digit = satisfy(isDigit)

letter :: Parser String
export letter = satisfy(isLetter)

letters :: Parser String
export letters = pipe(
  satisfy,
  many,
  map(reduce(mappend, ""))
)(isLetter)

