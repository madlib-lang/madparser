import {} from "Monad"
import {} from "Alternative"
import { apL } from "Applicative"
import { Either, Right, Left } from "Either"
import { Just, Nothing } from "Maybe"
import { firstChar, drop, isEmpty, isDigit, isLetter } from "String"
import { includes, reduce } from "List"
import { always, complement, equals, ifElse, notEquals } from "Function"
import {} from "Number"

export type Location = Loc Number Number Number

incLoc :: String -> Location -> Location
incLoc = (c) => where is Loc abs line col: c == "\n"
  ? Loc(abs + 1, line + 1, 0)
  : Loc(abs + 1, line, col + 1)

export type Parser a = Parser (String -> Location -> <List <a, String>, Location>)

export type Error = Error Location

parse :: Parser a -> String -> Location -> <List <a, String>, Location>
parse = (parser, input, loc) => {
  parseFn = where(parser)
    is Parser fn: fn
  return parseFn(input, loc)
}

/**
 * Runs a given parser with a given input. If it is successful it returns a Right
 * of the parsed type, otherwise it returns an error with the location of where
 * it failed.
 *
 * @since 0.0.1
 * @example
 * runParser(anyChar, "a")
 */
runParser :: Parser a -> String -> Either Error a
export runParser = (m, s) => where(parse(m, s, Loc(0, 0, 0)))
  is <[<res, "">], _>: Right(res)
  is <[<_, rest>], l>: Left(Error(l))
  is <_, l>          : Left(Error(l))

/**
 * maps the contained value of a Parser.
 *
 * @since 0.0.1
 * @example
 * type Letter = Letter String
 * map(Letter, anyChar) // Parser Letter
 */
instance Functor Parser {
  map = (f, m) => Parser((s, l) => where(parse(m, s, l))
    is <[<a, b>], loc>: <[<f(a), b>], loc>
    is <[], loc>      : <[], loc>
  )
}

/**
 * This is the heart of how parser combinators work. With ap you can apply many
 * arguments to a mapping function.
 *
 * @since 0.0.1
 * @example
 * parser = pipe(
 *   map((a, b, c) => a ++ b ++ c),
 *   ap($, abcParser),
 *   ap($, abcParser)
 * )(abcParser)
 */
instance Applicative Parser {
  pure = (a) => Parser((s, l) => <[<a, s>], l>)

  ap = (parserA, parserB) => Parser((s, l) =>
    where(parse(parserA, s, l)) {
      is <[], l1>       : <[], l1>
      is <[<f, s1>], l1>: where(parse(parserB, s1, l1)) {
        is <[<a, s2>], l2>: <[<f(a), s2>], l2>
        is <[], l2>       : <[], l2>
      }
    }
  )
}

/**
 * The Monad instance of Parser helps when you need to parse something based on
 * the previous computation.
 *
 * @since 0.0.1
 */
instance Monad Parser {
  of = pure

  chain = (f, m) => Parser((s, l) =>
    where(parse(m, s, l))
      is <[], ll>       : <[], ll>
      is <[<a, s1>], l1>: parse(f(a), s1, l1)
  )
}

/**
 * Alternative provides a way to fail over in case a parser failed. alt takes two
 * parsers, and if the first one fails, it tries to run the second one.
 *
 * @since 0.0.1
 * @example
 * runParser(alt(char("c"), char("a")), "a") // Right "a"
 */
instance Alternative Parser {
  empty = Parser((_, l) => <[], l>)

  alt = (ma, mb) => Parser((s, l) =>
    where(parse(ma, s, l))
      is <[], _> : parse(mb, s, l)
      is res     : res
  )
}

/**
 * A parser combinator that matches any character and returns a Parser String
 * containing that character.
 *
 * @since 0.0.1
 * @example
 * parse(anyChar, "?") // Right "?"
 */
anyChar :: Parser String
export anyChar = Parser((s, l) => pipe(
  firstChar,
  where
    is Just c : <[<c, drop(1, s)>], incLoc(c, l)>
    is Nothing: <[], l>
)(s))

/**
 * A parser combinator that returns the current location in the given input. This
 * combinator can be used to collect location information for your parsed AST.
 *
 * @since 0.0.1
 * @example
 * type Letter = L Location Location String
 * expected = Right()
 *
 * abcParser = pipe(
 *   map((start, c, end) => L(start, end, c)),
 *   ap($, oneOf(["a", "b", "c"])),
 *   ap($, location)
 * )(location)
 *
 * parser = pipe(
 *   map((a, b, c) => [a, b, c]),
 *   ap($, abcParser),
 *   ap($, abcParser)
 * )(abcParser)
 *
 * runParser(parser, "cba")
 * // Right [
 * //   L(Loc(0, 0, 0), Loc(1, 0, 1), "c"),
 * //   L(Loc(1, 0, 1), Loc(2, 0, 2), "b"),
 * //   L(Loc(2, 0, 2), Loc(3, 0, 3), "a")
 * // ]
 */
location :: Parser Location
export location = Parser((s, l) => <[<l, s>], l>)

/**
 * A parser combinator that matches any of the given characters.
 *
 * @since 0.0.1
 * @example
 * parse(oneOf(["1", "-", "?"]), "?") // Right "?"
 * parse(oneOf(["1", "-", "?"]), "1") // Right "1"
 * parse(oneOf(["1", "-", "?"]), "2") // Left (Loc 0 0 0)
 */
oneOf :: List String -> Parser String
export oneOf = (cs) => satisfy(includes($, cs))

/**
 * A parser combinator that matches all except the given characters.
 *
 * @since 0.0.1
 * @example
 * parse(notOneOf(["1", "-", "?"]), "?") // Left (Loc 0 0 0)
 * parse(notOneOf(["1", "-", "?"]), "1") // Left (Loc 0 0 0)
 * parse(notOneOf(["1", "-", "?"]), "2") // Right "2"
 */
notOneOf :: List String -> Parser String
export notOneOf = (cs) => satisfy(complement(includes($, cs)))


choice :: List (Parser a) -> Parser a
export choice = (ps) => reduce(alt, empty, ps)

many :: Parser a -> Parser (List a)
export many = (p) => alt(some(p), pure([]))

some :: Parser a -> Parser (List a)
export some = (p) => chain(
  (first) => map(
    (rest) => mappend([first], rest),
    many(p)
  ),
  p
)

manyTill :: Parser a -> Parser b -> Parser (List a)
export manyTill = (p, end) => pipe(
  map(always(Just(()))),
  alt($, pure(Nothing)),
  chain(where
    is Just _ : pure([])
    is Nothing: chain((x) => map((y) => mappend([x], y), manyTill(p, end)), p)
  )
)(end)

someTill :: Parser a -> Parser b -> Parser (List a)
export someTill = (p, end) => chain(
  (first) => map(
    (rest) => mappend([first], rest),
    manyTill(p, end)
  ),
  p
)

lookAhead :: Parser a -> Parser a
export lookAhead = (p) => Parser((s, l) => where(parse(p, s, l))
  is <[<a, _>], _>: <[<a, s>], l>
  is _            : <[], l>
)

takeWhile :: (String -> Boolean) -> Parser String
export takeWhile = (pred) => {
  parser = Parser((s, l) => where(parse(anyChar, s, l))
    is <[], _>          : <[<"", s>], l>
    is <[<"", _>], _>   : <[<"", s>], l>
    is <[<c, rest>], ll>: pred(c) ? <[<c, rest>], ll> : <[<"", s>], l>
  )

  return chain(
    ifElse(
      isEmpty,
      pure,
      (x) => map((next) => x ++ next, takeWhile(pred))
    ),
    parser
  )
}

satisfy :: (String -> Boolean) -> Parser String
export satisfy = (pred) => chain(
  ifElse(pred, of, always(empty)),
  anyChar
)

char :: String -> Parser String
export char = pipe(equals, satisfy)

notChar :: String -> Parser String
export notChar = pipe(notEquals, satisfy)

eof :: Parser ()
export eof = Parser((s, l) => where(parse(anyChar, s, l))
  is <[], _>: <[<(), "">], l>
  is _ : <[], l>
)

string :: String -> Parser String
export string = (s) => where(firstChar(s))
  is Just c :
    pipe(
      map((a, b) => a ++ b),
      ap($, string(drop(1, s)))
    )(char(c))
  is Nothing: pure("")

spaces :: Parser String
export spaces = pipe(
  oneOf,
  some,
  map(reduce(mappend, ""))
)([" ", "\n", "\r", "\t"])

token :: Parser a -> Parser a
export token = apL($, spaces)

symbol :: String -> Parser String
export symbol = pipe(string, token)

digit :: Parser String
export digit = satisfy(isDigit)

letter :: Parser String
export letter = satisfy(isLetter)

letters :: Parser String
export letters = pipe(
  satisfy,
  many,
  map(reduce(mappend, ""))
)(isLetter)

